% last updated in April 2002 by Antje Endemann
% Based on CVPR 07 and LNCS, with modifications by DAF, AZ and elle, 2008 and AA, 2010, and CC, 2011; TT, 2014

\documentclass[runningheads]{llncs}
\usepackage[width=122mm,left=12mm,paperwidth=146mm,height=193mm,top=12mm,paperheight=217mm]{geometry}

\usepackage{graphicx}

\usepackage{amsmath,amssymb} % define this before the line numbering.
\usepackage{ruler}
\usepackage{color}
% \usepackage{subfigure}
% 
% \usepackage{setspace}
\usepackage{algorithm}
\usepackage{epsfig}
% \usepackage[noend]{algorithmic}
% \newtheorem{thm}{Theorem}

\definecolor{orange}{rgb}{1,0.5,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkblue}{rgb}{0,0,0.5}

\def\etal{et al.\ }
\def\ie{i.e.\ }
\def\eg{e.g.\ }

%put a wide hat over the argumetn
\newcommand{\lift}[1]{\ensuremath{\widehat{#1}}}

%put a wide hat over the argumetn
%\newcommand{\lifto}[1]{\ensuremath{\check{#1}}}
\newcommand{\lifto}[1]{\ensuremath{\overset{_{_{\circ}}}{#1}}}


% stack vector
\newcommand{\stackv}[1]{\ensuremath{\vet{v}\left( {#1} \right)}}
\newcommand{\ustackv}[1]{\ensuremath{\inv{\vet{v}}\left( {#1} \right)}}

% symmetric stack vector
\newcommand{\stackvs}[1]{\ensuremath{\vet{v}_{\textit{sym}}\left( {#1} \right)}}

% Matrix Lifting: put a wide hat over the argument intended to be a matrix
\newcommand{\mlift}[1]{\ensuremath{\lift{\mat{#1}}}}
\newcommand{\mlifto}[1]{\ensuremath{\lifto{\mat{#1}}}}

% Vector Lifting: put a wide hat over the argument intended to be a matrix
\newcommand{\vlift}[1]{\ensuremath{\lift{\vet{#1}}}}
\newcommand{\vlifto}[1]{\ensuremath{\lifto{\vet{#1}}}}

\newcommand{\bmat}[1]{\ensuremath{\begin{bmatrix} #1 \end{bmatrix}}}
% Vector: print the argument as a vector
\newcommand{\vet}[1]{\ensuremath{\mathbf{#1}}}

% Matrix: print the argument as a matrix
\newcommand{\mat}[1]{\ensuremath{\,\mathtt{#1}\,}}

% Inverse: print a -1 on the top right of the argument 
\newcommand{\inv}[1]{\ensuremath{{#1}^{\text{-}1}}}

% Inverse: print a -1 on the top right of the argument 
\newcommand{\minv}[1]{\ensuremath{\mat{{#1}}^{\text{-}1}}}

% Transpose: print a T on the top right of the argument 
\newcommand{\tra}[1]{\ensuremath{{#1}^{\!\mathsf{T}}}}

% Transpose Matrix: print a T on the top right of the argument intended to be a matrix 
\newcommand{\mtra}[1]{\ensuremath{\tra{\mat{#1}}}}

% Transpose Vector: print a T on the top right of the argument intended to be a vector
\newcommand{\vtra}[1]{\ensuremath{\tra{\vet{#1}}}}

% minus transpose:  print a -T on the top right of the argument
\newcommand{\ment}[1]{\ensuremath{{#1}^{\text{-}\mathsf{T}}}}

% minus transpose matrix:  print a -T on the top right of the argument
\newcommand{\mment}[1]{\ensuremath{{\mat{#1}}^{\text{-}\mathsf{T}}}}

% Cross Matrix:  print the argument in the cross matrix notation
\newcommand{\crmat}[1]{\ensuremath{\left[{#1}\right]_{\times}}}

\newcommand{\mattwoone}[2]{\ensuremath{\left( \begin{array}{c} #1 \\ #2 \\ \end{array} \right)}}

\newcommand{\mattwotwo}[4]{\ensuremath{\left( \! \begin{array}{cc} #1 & #2 \\ #3 & #4 \\ \end{array} \! \right)}}

\newcommand{\matthreethree}[9]{\ensuremath{\left( \begin{array}{ccc} #1 & #2 & #3 \\ #4 & #5 & #6 \\ #7 & #8 & #9 \\ \end{array} \right)}}

\newcommand{\Vi}{\ensuremath{\mat{V}_{\!i}}}
\newcommand{\VF}{\ensuremath{\mat{V}^{\!F}}}
\newcommand{\VB}{\ensuremath{\mat{V}^{\!B}}}
\newcommand{\VirtualF}[1]{\ensuremath{\hat{\mat{#1}}^{\!F}}}
\newcommand{\VirtualB}[1]{\ensuremath{\hat{\mat{#1}}^{\!B}}}
\newcommand{\VFi}{\ensuremath{\mat{V}^{\!F}_{\!i}}}
\newcommand{\VBi}{\ensuremath{\mat{V}^{\!B}_{\!i}}}
\newcommand{\VirtualFi}[1]{\ensuremath{\hat{\mat{#1}}^{\!F}_{\!i}}}
\newcommand{\VirtualBi}[1]{\ensuremath{\hat{\mat{#1}}^{\!B}_{\!i}}}
\newcommand{\Si}{\ensuremath{\mat{S}_{\!i}}}
\newcommand{\Center}{\ensuremath{\vet{C}}}
\newcommand{\mirror}{\ensuremath{\mat{\Pi}}}

\newcommand{\testmath}[1]{\mathrm{#1} \mathit{#1} \mathbf{#1} \mathsf{#1} \mathtt{#1} \mathcal{#1} \mathbb{#1} \mathfrak{#1}} 

\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}


\newcommand{\todo}[1]{\fbox{\textcolor{red}{\textbf{ TODO: #1}}} \\}
\newcommand{\comment}[1]{{\small{\textsl{\textcolor{darkblue}{/* #1 */}}}}}
\newcommand{\draft}[1]{{\footnotesize{\textbf{\textcolor{blue}{Short version : compiling skipped}}}} \\}
\newcommand{\toadd}[1]{{\textbf{\textcolor{orange}{[ADD: #1]}}}}

\begin{document}
% \renewcommand\thelinenumber{\color[rgb]{0.2,0.5,0.8}\normalfont\sffamily\scriptsize\arabic{linenumber}\color[rgb]{0,0,0}}
% \renewcommand\makeLineNumber {\hss\thelinenumber\ \hspace{6mm} \rlap{\hskip\textwidth\ \hspace{6.5mm}\thelinenumber}}
% \linenumbers
\pagestyle{headings}
\mainmatter
\def\ECCV14SubNumber{979}  % Insert your submission number here

% \title{Geometric Extrinsic Calibration of Mobile Devices using a Planar Mirror:\\ Screen, Front and Rear Cameras} % Replace with your title
% \title{Screen, Front and Rear Cameras: How to Calibrate the Pose of your Smartphone?} % Replace with your title
% \title{Geometric Extrinsic Calibration of a Smartphone} % Replace with your title
% \title{How to Calibrate the Cameras of a Smartphone w.r.t its Screen?} % Replace with your title
\title{Statistic Criterion for Patch Comparison} % Replace with your title

\titlerunning{ECCV-14 submission ID \ECCV14SubNumber}

\authorrunning{ECCV-14 submission ID \ECCV14SubNumber}

\author{Anonymous ECCV submission}
\institute{Paper ID \ECCV14SubNumber}


\maketitle

\begin{abstract}
\end{abstract}


\section{Introduction}

Comparing patches is an operation used in many domains of image processing. Many modern methods for image registration and stereo-vision reconstruction rely heavily on estimating how much two patches (small square blocks of pixels) are similar. Patches are also used for denoising. In this work, we try to find an efficient way to know if two different patches are similar. Dissimilarity between two patches may have two main causes; the first is intrinsic (two different objects) and the other one is due to noise. Thus, noise should be taken into account in our criteria to know if patches describe the same object or not. As noise and natural images have very different characteristics, it is possible to make use of these differences to build a criteria that automatically reduces the influence of noise.
\\In section 2, we develop the likelihood ratio approach detailed by Deledalle et al in which we try to estimate a good statistic criterion for comparing two patches that takes into account independent noise in the patches. Then, we detail the a contrario method to learn a statistical distribution of the different patches. In section 4, we develop our method that uses this distribution as a prior for the likelihood ratio approach. We discuss our results and compare different methods in section 5.
% CITE

\subsection{Related Work}

\subsection{Contributions}

\subsection{Models and Notations}


\section{Likelihood Ratio for Patch Comparison}
In this framework, we model each observed patch of size $p$ by the realization $\mathbf{x} \in \mathcal{R}^p$ of a noise-free patch $\boldsymbol{\theta} \in \mathcal{R}^p$ deformed with noise. For example, if we consider normal additive noise, then we can write
\[
\mathbf{x} = \boldsymbol{\theta} + \mathbf{n}
\]
where $\mathbf{n} \in \mathcal{R}^p$ is a zero-mean normal distribution with variance $\sigma^2$ on each of its $p$ independent components. \\
We want to know if two observed patches $\mathbf{x}_1$ and $\mathbf{x}_2$ are two realizations of the same patch $\boldsymbol{\theta}_{12}$ deformed with noise (null hypothesis $\mathcal{H}_0$) or realizations of two different patches $\boldsymbol{\theta}_1 \neq \boldsymbol{\theta}_2$ (alternative hypothesis $\mathcal{H}_1$). \\
We give ourselves a criterion $\mathcal{C} : \mathcal{R}^p \times \mathcal{R}^p \rightarrow \mathcal{R}$ and a threshold $\tau$. We estimate that alternative hypothesis is verified if $\mathcal{C}(\mathbf{x}_1,\mathbf{x}_2)<\tau$. \\
Several statistic criteria can be used to compare patches. The Bayesian likelihood ratio is defined as the ratio of observing the patches under the two hypotheses:
\[
\mathcal{L}(\mathbf{x}_1,\mathbf{x}_2)=\frac{p(\mathbf{x}_1,\mathbf{x}_2|\mathcal{H}_0)}{p(\mathbf{x}_1,\mathbf{x}_2|\mathcal{H}_1)}
\]
To compute this, we have to condition upon the noise-free patches from which the observed patches may derive:
\[
\mathcal{L}(\mathbf{x}_1,\mathbf{x}_2)=
\frac{\int_{\mathbf{t \in \mathcal{R}^p}} p(\mathbf{x}_1|\boldsymbol{\theta}_{12}=\mathbf{t}) p(\mathbf{x}_2|\boldsymbol{\theta}_{12}=\mathbf{t})p(\boldsymbol{\theta}_{12}=\mathbf{t})\mathrm{d}\mathbf{t}}{\prod_{i=1,2}\int_{\mathbf{t \in \mathcal{R}^p}} p(\mathbf{x}_i|\boldsymbol{\theta}_{i}=\mathbf{t}) p(\boldsymbol{\theta}_{i}=\mathbf{t})\mathrm{d}\mathbf{t}}
\]
We have to make two assumptions to compute this ratio. First, the model of noise should be known, which allows us to compute $p(\mathbf{x}|\boldsymbol\theta)$. In the case of an additive, zero-mean normal noise of variance $\sigma^2$, we have
\[
p(\mathbf{x}|\boldsymbol\theta)\propto\exp\left(\frac{|\mathbf{x}-\boldsymbol\theta|^2}{2\sigma^2}\right)
\]
We also have to model $p(\boldsymbol\theta)$. In the case of the article from Deledalle et al., we use a non-informative prior (Jeffreys' prior), which minimizes a quantity that makes sense in information theory. However, in terms of images, we see that it comes down modeling the noise-free patches by realizations of noise. Under normal noise, computing the ratio under this hypothesis is equivalent to compute the euclidian distance between the two observations.\\
While the Bayesian likelihood ratio offers good theoretical properties, the computation of the integral may be long or impossible under certain circumstances. For this reason, we also introduce the generalized likelihood ratio which uses the maximum likelihood estimate for the noise-free patches:
\[
\mathcal{L}_G(\mathbf{x}_1,\mathbf{x}_2)=\frac{\sup_{\mathbf{t}}p(\mathbf{x}_1,\mathbf{x}_2|\boldsymbol\theta_{12}=\mathbf{t}, \mathcal{H}_0)}{\sup_{\mathbf{t}_1,\mathbf{t}_2}p(\mathbf{x}_1,\mathbf{x}_2|\boldsymbol\theta_i=\mathbf{t}_i, \mathcal{H}_1)}
\]
\subsection{Statistic Criterion for Patch Comparison}
\subsection{Likelihood Ratio and General Approach}

\section{A Contrario Model for Prior Learning}
\subsection{A Contrario Method}
\subsection{Model and Statistic}

\section{Likelihood Ratio with A Contrario Prior}
\subsection{Model}
\subsection{Studying}

\section{Experiments}
\subsection{Statistic Similarity for Non Local Means Denoising}
\subsection{PFA-PTD Performance}
\section{Conclusion}

\newpage

\bibliographystyle{splncs}
\bibliography{patch}
\end{document}
